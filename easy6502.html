
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta property="twitter:account_id" content="17736965">
    <title>Easy 6502 (sekol mod)</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="simulator/style.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Easy 6502</h1>
        <p><em>by</em> <a href="https://twitter.com/skilldrick">Nick Morgan</a>, licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></p>
        <p class="view"><a href="https://github.com/skilldrick/easy6502/tree/gh-pages">Fork me on GitHub</a></p>
        <ul>
          <li><a href="#intro">Introduction</a></li>
          <li><a href="#first-program">Our first program</a></li>
          <li><a href="#registers">Registers and flags</a></li>
          <li><a href="#instructions">Instructions</a></li>
          <li><a href="#branching">Branching</a></li>
          <li><a href="#addressing">Addressing modes</a></li>
          <li><a href="#stack">The stack</a></li>
          <li><a href="#jumping">Jumping</a></li>
          <li><a href="#snake">Creating a game</a></li>
        </ul>
      </header>
      <section>

        <h2 id="intro">Introduction</h2>

<p>In this tiny ebook I’m going to show you how to get started writing 6502
assembly language. The 6502 processor was massive in the seventies and
eighties, powering famous computers like the
<a href="http://en.wikipedia.org/wiki/BBC_Micro">BBC Micro</a>,
<a href="http://en.wikipedia.org/wiki/Atari_2600">Atari 2600</a>,
<a href="http://en.wikipedia.org/wiki/Commodore_64">Commodore 64</a>,
<a href="http://en.wikipedia.org/wiki/Apple_II">Apple II</a>, and the <a href="http://en.wikipedia.org/wiki/Nintendo_Entertainment_System">Nintendo Entertainment
System</a>. Bender in
Futurama <a href="http://www.transbyte.org/SID/SID-files/Bender_6502.jpg">has a 6502 processor for a
brain</a>. <a href="http://www.pagetable.com/docs/terminator/00-37-23.jpg">Even the
Terminator was programmed in
6502</a>.</p>

<p>So, why would you want to learn 6502? It’s a dead language isn’t it? Well,
so’s Latin. And they still teach that.
<a href="http://en.wikipedia.org/wiki/Q.E.D.">Q.E.D.</a></p>

<p>(Actually, I’ve been reliably informed that 6502 processors are still being
produced by <a href="http://www.westerndesigncenter.com/wdc/w65c02s-chip.cfm">Western Design Center</a>
and <a href="http://www.mouser.co.uk/Search/Refine.aspx?Keyword=65C02">sold to hobbyists</a>, so clearly 6502
<em>isn’t</em> a dead language! Who knew?)</p>

<p>Seriously though, I think it’s valuable to have an understanding of assembly
language. Assembly language is the lowest level of abstraction in computers -
the point at which the code is still readable. Assembly language translates
directly to the bytes that are executed by your computer’s processor.
If you understand how it works, you’ve basically become a computer
<a href="http://skilldrick.co.uk/2011/04/magic-in-software-development/">magician</a>.</p>

<p>Then why 6502? Why not a <em>useful</em> assembly language, like
<a href="http://en.wikipedia.org/wiki/X86">x86</a>? Well, I don’t think learning x86 is
useful. I don’t think you’ll ever have to <em>write</em> assembly language in your day
job - this is purely an academic exercise, something to expand your mind and
your thinking. 6502 was originally written in a different age, a time when the majority of
developers were writing assembly directly, rather than in these new-fangled
high-level programming languages. So, it was designed to be written by humans.
More modern assembly languages are meant to written by compilers, so let’s
leave it to them. Plus, 6502 is <em>fun</em>. Nobody ever called x86 <em>fun</em>.</p>

<h2 id="first-program">Our first program</h2>

<p>So, let’s dive in! That thing below is a little <a href="https://github.com/skilldrick/6502js">JavaScript 6502 assembler and
simulator</a> that I adapted for this book.
Click <strong>Assemble</strong> then <strong>Run</strong> to assemble and run the snippet of assembly language.</p>

<div class="widget">
  <div class="buttons">
    <input type="button" value="Assemble" class="assembleButton" />
    <input type="button" value="Run" class="runButton" />
    <input type="button" value="Reset" class="resetButton" />
    <input type="button" value="Hexdump" class="hexdumpButton" />
    <input type="button" value="Disassemble" class="disassembleButton" />
    <input type="button" value="Notes" class="notesButton" />
  </div>

  <textarea class="code">

LDA #$01
STA $0200
LDA #$05
STA $0201
LDA #$08
STA $0202

  </textarea>

  <canvas class="screen" width="160" height="160"></canvas>

  <div class="debugger">
    <input type="checkbox" class="debug" name="debug" />
    <label for="debug">Debugger</label>
    <div class="minidebugger"></div>
    <div class="buttons">
      <input type="button" value="Step" class="stepButton" />
      <input type="button" value="Jump to..." class="gotoButton" />
    </div>
  </div>

  <div class="monitorControls">
    <label for="monitoring">Monitor</label>
    <input type="checkbox" class="monitoring" name="monitoring" />

    <label for="start">Start: $</label>
    <input type="text" value="0" class="start" name="start" />
    <label for="length">Length: $</label>
    <input type="text" value="ff" class="length" name="length" />
  </div>

  <div class="monitor"><pre><code></code></pre></div>
  <div class="messages"><pre><code></code></pre></div>
  <div class="execution-dump"><pre><code></code></pre></div>
  <input type="button" value="Copy Execution Dump" class="copy-execution-dump" />      
  <input type="button" value="Copy Compressed Execution Dump" class="copy-compressed-execution-dump" />

  <div class="notes" style="display: none">Notes:

Memory location $fe contains a new random byte on every instruction.
Memory location $ff contains the ascii code of the last key pressed.

Memory locations $200 to $5ff map to the screen pixels. Different values will
draw different colour pixels. The colours are:

$0: Black
$1: White
$2: Red
$3: Cyan
$4: Purple
$5: Green
$6: Blue
$7: Yellow
$8: Orange
$9: Brown
$a: Light red
$b: Dark grey
$c: Grey
$d: Light green
$e: Light blue
$f: Light grey
    </div>
</div>

<p>Hopefully the black area on the right now has three coloured “pixels” at the
top left. (If this doesn’t work, you’ll probably need to upgrade your browser to
something more modern, like Chrome or Firefox.)</p>

<p>So, what’s this program actually doing? Let’s step through it with the
debugger. Hit <strong>Reset</strong>, then check the <strong>Debugger</strong> checkbox to start the
debugger. Click <strong>Step</strong> once. If you were watching carefully, you’ll have
noticed that <code class="language-plaintext highlighter-rouge">A=</code> changed from <code class="language-plaintext highlighter-rouge">$00</code> to <code class="language-plaintext highlighter-rouge">$01</code>, and <code class="language-plaintext highlighter-rouge">PC=</code> changed from <code class="language-plaintext highlighter-rouge">$0600</code> to
<code class="language-plaintext highlighter-rouge">$0602</code>.</p>

<p>Any numbers prefixed with <code class="language-plaintext highlighter-rouge">$</code> in 6502 assembly language (and by extension, in
this book) are in hexadecimal (hex) format. If you’re not familiar with hex
numbers, I recommend you read <a href="http://en.wikipedia.org/wiki/Hexadecimal">the Wikipedia
article</a>. Anything prefixed with <code class="language-plaintext highlighter-rouge">#</code>
is a literal number value. Any other number refers to a memory location.</p>

<p>Equipped with that knowledge, you should be able to see that the instruction
<code class="language-plaintext highlighter-rouge">LDA #$01</code> loads the hex value <code class="language-plaintext highlighter-rouge">$01</code> into register <code class="language-plaintext highlighter-rouge">A</code>. I’ll go into more
detail on registers in the next section.</p>

<p>Press <strong>Step</strong> again to execute the second instruction. The top-left pixel of
the simulator display should now be white. This simulator uses the memory
locations <code class="language-plaintext highlighter-rouge">$0200</code> to <code class="language-plaintext highlighter-rouge">$05ff</code> to draw pixels on its display. The values <code class="language-plaintext highlighter-rouge">$00</code> to
<code class="language-plaintext highlighter-rouge">$0f</code> represent 16 different colours (<code class="language-plaintext highlighter-rouge">$00</code> is black and <code class="language-plaintext highlighter-rouge">$01</code> is white), so
storing the value <code class="language-plaintext highlighter-rouge">$01</code> at memory location <code class="language-plaintext highlighter-rouge">$0200</code> draws a white pixel at the
top left corner. This is simpler than how an actual computer would output
video, but it’ll do for now.</p>

<p>So, the instruction <code class="language-plaintext highlighter-rouge">STA $0200</code> stores the value of the <code class="language-plaintext highlighter-rouge">A</code> register to memory
location <code class="language-plaintext highlighter-rouge">$0200</code>. Click <strong>Step</strong> four more times to execute the rest of the
instructions, keeping an eye on the <code class="language-plaintext highlighter-rouge">A</code> register as it changes.</p>

<h3 id="exercises">Exercises</h3>

<ol>
  <li>Try changing the colour of the three pixels.</li>
  <li>Change one of the pixels to draw at the bottom-right corner (memory location <code class="language-plaintext highlighter-rouge">$05ff</code>).</li>
  <li>Add more instructions to draw extra pixels.</li>
</ol>

<h2 id="registers">Registers and flags</h2>

<p>We’ve already had a little look at the processor status section (the bit with
<code class="language-plaintext highlighter-rouge">A</code>, <code class="language-plaintext highlighter-rouge">PC</code> etc.), but what does it all mean?</p>

<p>The first line shows the <code class="language-plaintext highlighter-rouge">A</code>, <code class="language-plaintext highlighter-rouge">X</code> and <code class="language-plaintext highlighter-rouge">Y</code> registers (<code class="language-plaintext highlighter-rouge">A</code> is often called the
“accumulator”). Each register holds a single byte. Most operations work on the
contents of these registers.</p>

<p><code class="language-plaintext highlighter-rouge">SP</code> is the stack pointer. I won’t get into the stack yet, but basically this
register is decremented every time a byte is pushed onto the stack, and
incremented when a byte is popped off the stack.</p>

<p><code class="language-plaintext highlighter-rouge">PC</code> is the program counter - it’s how the processor knows at what point in the
program it currently is. It’s like the current line number of an executing
script. In the JavaScript simulator the code is assembled starting at memory
location <code class="language-plaintext highlighter-rouge">$0600</code>, so <code class="language-plaintext highlighter-rouge">PC</code> always starts there.</p>

<p>The last section shows the processor flags. Each flag is one bit, so all seven
flags live in a single byte. The flags are set by the processor to give
information about the previous instruction. More on that later. <a href="http://www.obelisk.me.uk/6502/registers.html">Read more
about the registers and flags here</a>.</p>

<h2 id="instructions">Instructions</h2>

<p>Instructions in assembly language are like a small set of predefined functions.
All instructions take zero or one arguments. Here’s some annotated
source code to introduce a few different instructions:</p>

<div class="widget">
  <div class="buttons">
    <input type="button" value="Assemble" class="assembleButton" />
    <input type="button" value="Run" class="runButton" />
    <input type="button" value="Reset" class="resetButton" />
    <input type="button" value="Hexdump" class="hexdumpButton" />
    <input type="button" value="Disassemble" class="disassembleButton" />
    <input type="button" value="Notes" class="notesButton" />
  </div>

  <textarea class="code">

LDA #$c0  ;Load the hex value $c0 into the A register
TAX       ;Transfer the value in the A register to X
INX       ;Increment the value in the X register
ADC #$c4  ;Add the hex value $c4 to the A register
BRK       ;Break - we're done

  </textarea>

  <canvas class="screen" width="160" height="160"></canvas>

  <div class="debugger">
    <input type="checkbox" class="debug" name="debug" />
    <label for="debug">Debugger</label>
    <div class="minidebugger"></div>
    <div class="buttons">
      <input type="button" value="Step" class="stepButton" />
      <input type="button" value="Jump to..." class="gotoButton" />
    </div>
  </div>

  <div class="monitorControls">
    <label for="monitoring">Monitor</label>
    <input type="checkbox" class="monitoring" name="monitoring" />

    <label for="start">Start: $</label>
    <input type="text" value="0" class="start" name="start" />
    <label for="length">Length: $</label>
    <input type="text" value="ff" class="length" name="length" />
  </div>

  <div class="monitor"><pre><code></code></pre></div>
  <div class="messages"><pre><code></code></pre></div>
  <div class="execution-dump"><pre><code></code></pre></div>
  <input type="button" value="Copy Execution Dump" class="copy-execution-dump" />
  <input type="button" value="Copy Compressed Execution Dump" class="copy-compressed-execution-dump" />

  <div class="notes" style="display: none">Notes:

Memory location $fe contains a new random byte on every instruction.
Memory location $ff contains the ascii code of the last key pressed.

Memory locations $200 to $5ff map to the screen pixels. Different values will
draw different colour pixels. The colours are:

$0: Black
$1: White
$2: Red
$3: Cyan
$4: Purple
$5: Green
$6: Blue
$7: Yellow
$8: Orange
$9: Brown
$a: Light red
$b: Dark grey
$c: Grey
$d: Light green
$e: Light blue
$f: Light grey
    </div>
</div>

<p>Assemble the code, then turn on the debugger and step through the code, watching
the <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">X</code> registers. Something slightly odd happens on the line <code class="language-plaintext highlighter-rouge">ADC #$c4</code>.
You might expect that adding <code class="language-plaintext highlighter-rouge">$c4</code> to <code class="language-plaintext highlighter-rouge">$c0</code> would give <code class="language-plaintext highlighter-rouge">$184</code>, but this
processor gives the result as <code class="language-plaintext highlighter-rouge">$84</code>. What’s up with that?</p>

<p>The problem is, <code class="language-plaintext highlighter-rouge">$184</code> is too big to fit in a single byte (the max is <code class="language-plaintext highlighter-rouge">$FF</code>),
and the registers can only hold a single byte.  It’s OK though; the processor
isn’t actually dumb. If you were looking carefully enough, you’ll have noticed
that the carry flag was set to <code class="language-plaintext highlighter-rouge">1</code> after this operation. So that’s how you
know.</p>

<p>In the simulator below <strong>type</strong> (don’t paste) the following code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LDA #$80
STA $01
ADC $01
</code></pre></div></div>

<div class="widget">
  <div class="buttons">
    <input type="button" value="Assemble" class="assembleButton" />
    <input type="button" value="Run" class="runButton" />
    <input type="button" value="Reset" class="resetButton" />
    <input type="button" value="Hexdump" class="hexdumpButton" />
    <input type="button" value="Disassemble" class="disassembleButton" />
    <input type="button" value="Notes" class="notesButton" />
  </div>

  <textarea class="code"></textarea>

  <canvas class="screen" width="160" height="160"></canvas>

  <div class="debugger">
    <input type="checkbox" class="debug" name="debug" />
    <label for="debug">Debugger</label>
    <div class="minidebugger"></div>
    <div class="buttons">
      <input type="button" value="Step" class="stepButton" />
      <input type="button" value="Jump to..." class="gotoButton" />
    </div>
  </div>

  <div class="monitorControls">
    <label for="monitoring">Monitor</label>
    <input type="checkbox" class="monitoring" name="monitoring" />

    <label for="start">Start: $</label>
    <input type="text" value="0" class="start" name="start" />
    <label for="length">Length: $</label>
    <input type="text" value="ff" class="length" name="length" />
  </div>

  <div class="monitor"><pre><code></code></pre></div>
  <div class="messages"><pre><code></code></pre></div>
  <div class="execution-dump"><pre><code></code></pre></div>
  <input type="button" value="Copy Execution Dump" class="copy-execution-dump" />      

  <div class="notes" style="display: none">Notes:

Memory location $fe contains a new random byte on every instruction.
Memory location $ff contains the ascii code of the last key pressed.

Memory locations $200 to $5ff map to the screen pixels. Different values will
draw different colour pixels. The colours are:

$0: Black
$1: White
$2: Red
$3: Cyan
$4: Purple
$5: Green
$6: Blue
$7: Yellow
$8: Orange
$9: Brown
$a: Light red
$b: Dark grey
$c: Grey
$d: Light green
$e: Light blue
$f: Light grey
    </div>
</div>

<p>An important thing to notice here is the distinction between <code class="language-plaintext highlighter-rouge">ADC #$01</code> and
<code class="language-plaintext highlighter-rouge">ADC $01</code>. The first one adds the value <code class="language-plaintext highlighter-rouge">$01</code> to the <code class="language-plaintext highlighter-rouge">A</code> register, but the
second adds the value stored at memory location <code class="language-plaintext highlighter-rouge">$01</code> to the <code class="language-plaintext highlighter-rouge">A</code> register.</p>

<p>Assemble, check the <strong>Monitor</strong> checkbox, then step through these three
instructions. The monitor shows a section of memory, and can be helpful to
visualise the execution of programs. <code class="language-plaintext highlighter-rouge">STA $01</code> stores the value of the <code class="language-plaintext highlighter-rouge">A</code>
register at memory location <code class="language-plaintext highlighter-rouge">$01</code>, and <code class="language-plaintext highlighter-rouge">ADC $01</code> adds the value stored at the
memory location <code class="language-plaintext highlighter-rouge">$01</code> to the <code class="language-plaintext highlighter-rouge">A</code> register. <code class="language-plaintext highlighter-rouge">$80 + $80</code> should equal <code class="language-plaintext highlighter-rouge">$100</code>, but
because this is bigger than a byte, the <code class="language-plaintext highlighter-rouge">A</code> register is set to <code class="language-plaintext highlighter-rouge">$00</code> and the
carry flag is set. As well as this though, the zero flag is set. The zero flag
is set by all instructions where the result is zero.</p>

<p>A full list of the 6502 instruction set is <a href="http://www.6502.org/tutorials/6502opcodes.html">available
here</a> and
<a href="http://www.obelisk.me.uk/6502/reference.html">here</a> (I usually refer to
both pages as they have their strengths and weaknesses). These pages detail the
arguments to each instruction, which registers they use, and which flags they
set. They are your bible.</p>

<h3 id="exercises-1">Exercises</h3>

<ol>
  <li>You’ve seen <code class="language-plaintext highlighter-rouge">TAX</code>. You can probably guess what <code class="language-plaintext highlighter-rouge">TAY</code>, <code class="language-plaintext highlighter-rouge">TXA</code> and <code class="language-plaintext highlighter-rouge">TYA</code> do,
but write some code to test your assumptions.</li>
  <li>Rewrite the first example in this section to use the <code class="language-plaintext highlighter-rouge">Y</code> register instead of
the <code class="language-plaintext highlighter-rouge">X</code> register.</li>
  <li>The opposite of <code class="language-plaintext highlighter-rouge">ADC</code> is <code class="language-plaintext highlighter-rouge">SBC</code> (subtract with carry). Write a program that
uses this instruction.</li>
</ol>

<h2 id="branching">Branching</h2>

<p>So far we’re only able to write basic programs without any branching logic.
Let’s change that.</p>

<p>6502 assembly language has a bunch of branching instructions, all of which
branch based on whether certain flags are set or not. In this example we’ll be
looking at <code class="language-plaintext highlighter-rouge">BNE</code>: “Branch on not equal”.</p>

<div class="widget">
  <div class="buttons">
    <input type="button" value="Assemble" class="assembleButton" />
    <input type="button" value="Run" class="runButton" />
    <input type="button" value="Reset" class="resetButton" />
    <input type="button" value="Hexdump" class="hexdumpButton" />
    <input type="button" value="Disassemble" class="disassembleButton" />
    <input type="button" value="Notes" class="notesButton" />
  </div>

  <textarea class="code">

  LDX #$08
decrement:
  DEX
  STX $0200
  CPX #$03
  BNE decrement
  STX $0201
  BRK

  </textarea>

  <canvas class="screen" width="160" height="160"></canvas>

  <div class="debugger">
    <input type="checkbox" class="debug" name="debug" />
    <label for="debug">Debugger</label>
    <div class="minidebugger"></div>
    <div class="buttons">
      <input type="button" value="Step" class="stepButton" />
      <input type="button" value="Jump to..." class="gotoButton" />
    </div>
  </div>

  <div class="monitorControls">
    <label for="monitoring">Monitor</label>
    <input type="checkbox" class="monitoring" name="monitoring" />

    <label for="start">Start: $</label>
    <input type="text" value="0" class="start" name="start" />
    <label for="length">Length: $</label>
    <input type="text" value="ff" class="length" name="length" />
  </div>

  <div class="monitor"><pre><code></code></pre></div>
  <div class="messages"><pre><code></code></pre></div>
  <div class="execution-dump"><pre><code></code></pre></div>
  <input type="button" value="Copy Execution Dump" class="copy-execution-dump" />      

  <div class="notes" style="display: none">Notes:

Memory location $fe contains a new random byte on every instruction.
Memory location $ff contains the ascii code of the last key pressed.

Memory locations $200 to $5ff map to the screen pixels. Different values will
draw different colour pixels. The colours are:

$0: Black
$1: White
$2: Red
$3: Cyan
$4: Purple
$5: Green
$6: Blue
$7: Yellow
$8: Orange
$9: Brown
$a: Light red
$b: Dark grey
$c: Grey
$d: Light green
$e: Light blue
$f: Light grey
    </div>
</div>

<p>First we load the value <code class="language-plaintext highlighter-rouge">$08</code> into the <code class="language-plaintext highlighter-rouge">X</code> register. The next line is a label.
Labels just mark certain points in a program so we can return to them later.
After the label we decrement <code class="language-plaintext highlighter-rouge">X</code>, store it to <code class="language-plaintext highlighter-rouge">$0200</code> (the top-left pixel), and
then compare it to the value <code class="language-plaintext highlighter-rouge">$03</code>.
<a href="http://www.obelisk.me.uk/6502/reference.html#CPX"><code class="language-plaintext highlighter-rouge">CPX</code></a> compares the
value in the <code class="language-plaintext highlighter-rouge">X</code> register with another value. If the two values are equal, the
<code class="language-plaintext highlighter-rouge">Z</code> flag is set to <code class="language-plaintext highlighter-rouge">1</code>, otherwise it is set to <code class="language-plaintext highlighter-rouge">0</code>.</p>

<p>The next line, <code class="language-plaintext highlighter-rouge">BNE decrement</code>, will shift execution to the decrement label if
the <code class="language-plaintext highlighter-rouge">Z</code> flag is set to <code class="language-plaintext highlighter-rouge">0</code> (meaning that the two values in the <code class="language-plaintext highlighter-rouge">CPX</code> comparison
were not equal), otherwise it does nothing and we store <code class="language-plaintext highlighter-rouge">X</code> to <code class="language-plaintext highlighter-rouge">$0201</code>, then
finish the program.</p>

<p>In assembly language, you’ll usually use labels with branch instructions. When
assembled though, this label is converted to a single-byte relative offset (a
number of bytes to go backwards or forwards from the next instruction) so
branch instructions can only go forward and back around 256 bytes. This means
they can only be used to move around local code. For moving further you’ll need
to use the jumping instructions.</p>

<h3 id="exercises-2">Exercises</h3>

<ol>
  <li>The opposite of <code class="language-plaintext highlighter-rouge">BNE</code> is <code class="language-plaintext highlighter-rouge">BEQ</code>. Try writing a program that uses <code class="language-plaintext highlighter-rouge">BEQ</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">BCC</code> and <code class="language-plaintext highlighter-rouge">BCS</code> (“branch on carry clear” and “branch on carry set”) are used
to branch on the carry flag. Write a program that uses one of these two.</li>
</ol>

<h2 id="addressing">Addressing modes</h2>

<p>The 6502 uses a 16-bit address bus, meaning that there are 65536 bytes of
memory available to the processor. Remember that a byte is represented by two
hex characters, so the memory locations are generally represented as <code class="language-plaintext highlighter-rouge">$0000 -
$ffff</code>. There are various ways to refer to these memory locations, as detailed below.</p>

<p>With all these examples you might find it helpful to use the memory monitor to
watch the memory change. The monitor takes a starting memory location and a
number of bytes to display from that location. Both of these are hex values.
For example, to display 16 bytes of memory from <code class="language-plaintext highlighter-rouge">$c000</code>, enter <code class="language-plaintext highlighter-rouge">c000</code> and <code class="language-plaintext highlighter-rouge">10</code>
into <strong>Start</strong> and <strong>Length</strong>, respectively.</p>

<h3 id="absolute-c000">Absolute: <code class="language-plaintext highlighter-rouge">$c000</code></h3>

<p>With absolute addressing, the full memory location is used as the argument to the instruction. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>STA $c000 ;Store the value in the accumulator at memory location $c000
</code></pre></div></div>

<h3 id="zero-page-c0">Zero page: <code class="language-plaintext highlighter-rouge">$c0</code></h3>

<p>All instructions that support absolute addressing (with the exception of the jump
instructions) also have the option to take a single-byte address. This type of
addressing is called “zero page” - only the first page (the first 256 bytes) of
memory is accessible. This is faster, as only one byte needs to be looked up,
and takes up less space in the assembled code as well.</p>

<h3 id="zero-pagex-c0x">Zero page,X: <code class="language-plaintext highlighter-rouge">$c0,X</code></h3>

<p>This is where addressing gets interesting. In this mode, a zero page address is given, and then the value of the <code class="language-plaintext highlighter-rouge">X</code> register is added. Here is an example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LDX #$01   ;X is $01
LDA #$aa   ;A is $aa
STA $a0,X ;Store the value of A at memory location $a1
INX        ;Increment X
STA $a0,X ;Store the value of A at memory location $a2
</code></pre></div></div>

<p>If the result of the addition is larger than a single byte, the address wraps around. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LDX #$05
STA $ff,X ;Store the value of A at memory location $04
</code></pre></div></div>

<h3 id="zero-pagey-c0y">Zero page,Y: <code class="language-plaintext highlighter-rouge">$c0,Y</code></h3>

<p>This is the equivalent of zero page,X, but can only be used with <code class="language-plaintext highlighter-rouge">LDX</code> and <code class="language-plaintext highlighter-rouge">STX</code>.</p>

<h3 id="absolutex-and-absolutey-c000x-and-c000y">Absolute,X and absolute,Y: <code class="language-plaintext highlighter-rouge">$c000,X</code> and <code class="language-plaintext highlighter-rouge">$c000,Y</code></h3>

<p>These are the absolute addressing versions of zero page,X and zero page,Y. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LDX #$01
STA $0200,X ;Store the value of A at memory location $0201
</code></pre></div></div>

<h3 id="immediate-c0">Immediate: <code class="language-plaintext highlighter-rouge">#$c0</code></h3>

<p>Immediate addressing doesn’t strictly deal with memory addresses - this is the
mode where actual values are used. For example, <code class="language-plaintext highlighter-rouge">LDX #$01</code> loads the value
<code class="language-plaintext highlighter-rouge">$01</code> into the <code class="language-plaintext highlighter-rouge">X</code> register. This is very different to the zero page
instruction <code class="language-plaintext highlighter-rouge">LDX $01</code> which loads the value at memory location <code class="language-plaintext highlighter-rouge">$01</code> into the
<code class="language-plaintext highlighter-rouge">X</code> register.</p>

<h3 id="relative-c0-or-label">Relative: <code class="language-plaintext highlighter-rouge">$c0</code> (or label)</h3>

<p>Relative addressing is used for branching instructions. These instructions take
a single byte, which is used as an offset from the following instruction.</p>

<p>Assemble the following code, then click the <strong>Hexdump</strong> button to see the assembled code.</p>

<div class="widget">
  <div class="buttons">
    <input type="button" value="Assemble" class="assembleButton" />
    <input type="button" value="Run" class="runButton" />
    <input type="button" value="Reset" class="resetButton" />
    <input type="button" value="Hexdump" class="hexdumpButton" />
    <input type="button" value="Disassemble" class="disassembleButton" />
    <input type="button" value="Notes" class="notesButton" />
  </div>

  <textarea class="code">

  LDA #$01
  CMP #$02
  BNE notequal
  STA $22
notequal:
  BRK

  </textarea>

  <canvas class="screen" width="160" height="160"></canvas>

  <div class="debugger">
    <input type="checkbox" class="debug" name="debug" />
    <label for="debug">Debugger</label>
    <div class="minidebugger"></div>
    <div class="buttons">
      <input type="button" value="Step" class="stepButton" />
      <input type="button" value="Jump to..." class="gotoButton" />
    </div>
  </div>

  <div class="monitorControls">
    <label for="monitoring">Monitor</label>
    <input type="checkbox" class="monitoring" name="monitoring" />

    <label for="start">Start: $</label>
    <input type="text" value="0" class="start" name="start" />
    <label for="length">Length: $</label>
    <input type="text" value="ff" class="length" name="length" />
  </div>

  <div class="monitor"><pre><code></code></pre></div>
  <div class="messages"><pre><code></code></pre></div>
  <div class="execution-dump"><pre><code></code></pre></div>
  <input type="button" value="Copy Execution Dump" class="copy-execution-dump" />      

  <div class="notes" style="display: none">Notes:

Memory location $fe contains a new random byte on every instruction.
Memory location $ff contains the ascii code of the last key pressed.

Memory locations $200 to $5ff map to the screen pixels. Different values will
draw different colour pixels. The colours are:

$0: Black
$1: White
$2: Red
$3: Cyan
$4: Purple
$5: Green
$6: Blue
$7: Yellow
$8: Orange
$9: Brown
$a: Light red
$b: Dark grey
$c: Grey
$d: Light green
$e: Light blue
$f: Light grey
    </div>
</div>

<p>The hex should look something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a9 01 c9 02 d0 02 85 22 00
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">a9</code> and <code class="language-plaintext highlighter-rouge">c9</code> are the processor opcodes for immediate-addressed <code class="language-plaintext highlighter-rouge">LDA</code> and <code class="language-plaintext highlighter-rouge">CMP</code>
respectively. <code class="language-plaintext highlighter-rouge">01</code> and <code class="language-plaintext highlighter-rouge">02</code> are the arguments to these instructions. <code class="language-plaintext highlighter-rouge">d0</code> is
the opcode for <code class="language-plaintext highlighter-rouge">BNE</code>, and its argument is <code class="language-plaintext highlighter-rouge">02</code>. This means “skip over the next
two bytes” (<code class="language-plaintext highlighter-rouge">85 22</code>, the assembled version of <code class="language-plaintext highlighter-rouge">STA $22</code>). Try editing the code
so <code class="language-plaintext highlighter-rouge">STA</code> takes a two-byte absolute address rather than a single-byte zero page
address (e.g. change <code class="language-plaintext highlighter-rouge">STA $22</code> to <code class="language-plaintext highlighter-rouge">STA $2222</code>). Reassemble the code and look at
the hexdump again - the argument to <code class="language-plaintext highlighter-rouge">BNE</code> should now be <code class="language-plaintext highlighter-rouge">03</code>, because the
instruction the processor is skipping past is now three bytes long.</p>

<h3 id="implicit">Implicit</h3>

<p>Some instructions don’t deal with memory locations (e.g. <code class="language-plaintext highlighter-rouge">INX</code> - increment the
<code class="language-plaintext highlighter-rouge">X</code> register). These are said to have implicit addressing - the argument is
implied by the instruction.</p>

<h3 id="indirect-c000">Indirect: <code class="language-plaintext highlighter-rouge">($c000)</code></h3>

<p>Indirect addressing uses an absolute address to look up another address. The
first address gives the least significant byte of the address, and the
following byte gives the most significant byte. That can be hard to wrap your
head around, so here’s an example:</p>

<div class="widget">
  <div class="buttons">
    <input type="button" value="Assemble" class="assembleButton" />
    <input type="button" value="Run" class="runButton" />
    <input type="button" value="Reset" class="resetButton" />
    <input type="button" value="Hexdump" class="hexdumpButton" />
    <input type="button" value="Disassemble" class="disassembleButton" />
    <input type="button" value="Notes" class="notesButton" />
  </div>

  <textarea class="code">

LDA #$01
STA $f0
LDA #$cc
STA $f1
JMP ($00f0) ;dereferences to $cc01

  </textarea>

  <canvas class="screen" width="160" height="160"></canvas>

  <div class="debugger">
    <input type="checkbox" class="debug" name="debug" />
    <label for="debug">Debugger</label>
    <div class="minidebugger"></div>
    <div class="buttons">
      <input type="button" value="Step" class="stepButton" />
      <input type="button" value="Jump to..." class="gotoButton" />
    </div>
  </div>

  <div class="monitorControls">
    <label for="monitoring">Monitor</label>
    <input type="checkbox" class="monitoring" name="monitoring" />

    <label for="start">Start: $</label>
    <input type="text" value="0" class="start" name="start" />
    <label for="length">Length: $</label>
    <input type="text" value="ff" class="length" name="length" />
  </div>

  <div class="monitor"><pre><code></code></pre></div>
  <div class="messages"><pre><code></code></pre></div>
  <div class="execution-dump"><pre><code></code></pre></div>
  <input type="button" value="Copy Execution Dump" class="copy-execution-dump" />      

  <div class="notes" style="display: none">Notes:

Memory location $fe contains a new random byte on every instruction.
Memory location $ff contains the ascii code of the last key pressed.

Memory locations $200 to $5ff map to the screen pixels. Different values will
draw different colour pixels. The colours are:

$0: Black
$1: White
$2: Red
$3: Cyan
$4: Purple
$5: Green
$6: Blue
$7: Yellow
$8: Orange
$9: Brown
$a: Light red
$b: Dark grey
$c: Grey
$d: Light green
$e: Light blue
$f: Light grey
    </div>
</div>

<p>In this example, <code class="language-plaintext highlighter-rouge">$f0</code> contains the value <code class="language-plaintext highlighter-rouge">$01</code> and <code class="language-plaintext highlighter-rouge">$f1</code> contains the value
<code class="language-plaintext highlighter-rouge">$cc</code>. The instruction <code class="language-plaintext highlighter-rouge">JMP ($f0)</code> causes the processor to look up the two
bytes at <code class="language-plaintext highlighter-rouge">$f0</code> and <code class="language-plaintext highlighter-rouge">$f1</code> (<code class="language-plaintext highlighter-rouge">$01</code> and <code class="language-plaintext highlighter-rouge">$cc</code>) and put them together to form the
address <code class="language-plaintext highlighter-rouge">$cc01</code>, which becomes the new program counter. Assemble and step
through the program above to see what happens. I’ll talk more about <code class="language-plaintext highlighter-rouge">JMP</code> in
the section on <a href="#jumping">Jumping</a>.</p>

<h3 id="indexed-indirect-c0x">Indexed indirect: <code class="language-plaintext highlighter-rouge">($c0,X)</code></h3>

<p>This one’s kinda weird. It’s like a cross between zero page,X and indirect.
Basically, you take the zero page address, add the value of the <code class="language-plaintext highlighter-rouge">X</code> register to
it, then use that to look up a two-byte address. For example:</p>

<div class="widget">
  <div class="buttons">
    <input type="button" value="Assemble" class="assembleButton" />
    <input type="button" value="Run" class="runButton" />
    <input type="button" value="Reset" class="resetButton" />
    <input type="button" value="Hexdump" class="hexdumpButton" />
    <input type="button" value="Disassemble" class="disassembleButton" />
    <input type="button" value="Notes" class="notesButton" />
  </div>

  <textarea class="code">

LDX #$01
LDA #$05
STA $01
LDA #$07
STA $02
LDY #$0a
STY $0705
LDA ($00,X)

  </textarea>

  <canvas class="screen" width="160" height="160"></canvas>

  <div class="debugger">
    <input type="checkbox" class="debug" name="debug" />
    <label for="debug">Debugger</label>
    <div class="minidebugger"></div>
    <div class="buttons">
      <input type="button" value="Step" class="stepButton" />
      <input type="button" value="Jump to..." class="gotoButton" />
    </div>
  </div>

  <div class="monitorControls">
    <label for="monitoring">Monitor</label>
    <input type="checkbox" class="monitoring" name="monitoring" />

    <label for="start">Start: $</label>
    <input type="text" value="0" class="start" name="start" />
    <label for="length">Length: $</label>
    <input type="text" value="ff" class="length" name="length" />
  </div>

  <div class="monitor"><pre><code></code></pre></div>
  <div class="messages"><pre><code></code></pre></div>
  <div class="execution-dump"><pre><code></code></pre></div>
  <input type="button" value="Copy Execution Dump" class="copy-execution-dump" />      

  <div class="notes" style="display: none">Notes:

Memory location $fe contains a new random byte on every instruction.
Memory location $ff contains the ascii code of the last key pressed.

Memory locations $200 to $5ff map to the screen pixels. Different values will
draw different colour pixels. The colours are:

$0: Black
$1: White
$2: Red
$3: Cyan
$4: Purple
$5: Green
$6: Blue
$7: Yellow
$8: Orange
$9: Brown
$a: Light red
$b: Dark grey
$c: Grey
$d: Light green
$e: Light blue
$f: Light grey
    </div>
</div>

<p>Memory locations <code class="language-plaintext highlighter-rouge">$01</code> and <code class="language-plaintext highlighter-rouge">$02</code> contain the values <code class="language-plaintext highlighter-rouge">$05</code> and <code class="language-plaintext highlighter-rouge">$07</code>
respectively. Think of <code class="language-plaintext highlighter-rouge">($00,X)</code> as <code class="language-plaintext highlighter-rouge">($00 + X)</code>. In this case <code class="language-plaintext highlighter-rouge">X</code> is <code class="language-plaintext highlighter-rouge">$01</code>, so
this simplifies to <code class="language-plaintext highlighter-rouge">($01)</code>. From here things proceed like standard indirect
addressing - the two bytes at <code class="language-plaintext highlighter-rouge">$01</code> and <code class="language-plaintext highlighter-rouge">$02</code> (<code class="language-plaintext highlighter-rouge">$05</code> and <code class="language-plaintext highlighter-rouge">$07</code>) are looked up
to form the address <code class="language-plaintext highlighter-rouge">$0705</code>.  This is the address that the <code class="language-plaintext highlighter-rouge">Y</code> register was
stored into in the previous instruction, so the <code class="language-plaintext highlighter-rouge">A</code> register gets the same
value as <code class="language-plaintext highlighter-rouge">Y</code>, albeit through a much more circuitous route. You won’t see this
much.</p>

<h3 id="indirect-indexed-c0y">Indirect indexed: <code class="language-plaintext highlighter-rouge">($c0),Y</code></h3>

<p>Indirect indexed is like indexed indirect but less insane. Instead of adding
the <code class="language-plaintext highlighter-rouge">X</code> register to the address <em>before</em> dereferencing, the zero page address
is dereferenced, and the <code class="language-plaintext highlighter-rouge">Y</code> register is added to the resulting address.</p>

<div class="widget">
  <div class="buttons">
    <input type="button" value="Assemble" class="assembleButton" />
    <input type="button" value="Run" class="runButton" />
    <input type="button" value="Reset" class="resetButton" />
    <input type="button" value="Hexdump" class="hexdumpButton" />
    <input type="button" value="Disassemble" class="disassembleButton" />
    <input type="button" value="Notes" class="notesButton" />
  </div>

  <textarea class="code">

LDY #$01
LDA #$03
STA $01
LDA #$07
STA $02
LDX #$0a
STX $0704
LDA ($01),Y

  </textarea>

  <canvas class="screen" width="160" height="160"></canvas>

  <div class="debugger">
    <input type="checkbox" class="debug" name="debug" />
    <label for="debug">Debugger</label>
    <div class="minidebugger"></div>
    <div class="buttons">
      <input type="button" value="Step" class="stepButton" />
      <input type="button" value="Jump to..." class="gotoButton" />
    </div>
  </div>

  <div class="monitorControls">
    <label for="monitoring">Monitor</label>
    <input type="checkbox" class="monitoring" name="monitoring" />

    <label for="start">Start: $</label>
    <input type="text" value="0" class="start" name="start" />
    <label for="length">Length: $</label>
    <input type="text" value="ff" class="length" name="length" />
  </div>

  <div class="monitor"><pre><code></code></pre></div>
  <div class="messages"><pre><code></code></pre></div>
  <div class="execution-dump"><pre><code></code></pre></div>
  <input type="button" value="Copy Execution Dump" class="copy-execution-dump" />      

  <div class="notes" style="display: none">Notes:

Memory location $fe contains a new random byte on every instruction.
Memory location $ff contains the ascii code of the last key pressed.

Memory locations $200 to $5ff map to the screen pixels. Different values will
draw different colour pixels. The colours are:

$0: Black
$1: White
$2: Red
$3: Cyan
$4: Purple
$5: Green
$6: Blue
$7: Yellow
$8: Orange
$9: Brown
$a: Light red
$b: Dark grey
$c: Grey
$d: Light green
$e: Light blue
$f: Light grey
    </div>
</div>

<p>In this case, <code class="language-plaintext highlighter-rouge">($01)</code> looks up the two bytes at <code class="language-plaintext highlighter-rouge">$01</code> and <code class="language-plaintext highlighter-rouge">$02</code>: <code class="language-plaintext highlighter-rouge">$03</code> and
<code class="language-plaintext highlighter-rouge">$07</code>. These form the address <code class="language-plaintext highlighter-rouge">$0703</code>. The value of the <code class="language-plaintext highlighter-rouge">Y</code> register is added
to this address to give the final address <code class="language-plaintext highlighter-rouge">$0704</code>.</p>

<h3 id="exercise">Exercise</h3>

<ol>
  <li>Try to write code snippets that use each of the 6502 addressing modes.
Remember, you can use the monitor to watch a section of memory.</li>
</ol>

<h2 id="stack">The stack</h2>

<p>The stack in a 6502 processor is just like any other stack - values are pushed
onto it and popped (“pulled” in 6502 parlance) off it. The current depth of the
stack is measured by the stack pointer, a special register. The stack lives in
memory between <code class="language-plaintext highlighter-rouge">$0100</code> and <code class="language-plaintext highlighter-rouge">$01ff</code>. The stack pointer is initially <code class="language-plaintext highlighter-rouge">$ff</code>, which
points to memory location <code class="language-plaintext highlighter-rouge">$01ff</code>. When a byte is pushed onto the stack, the
stack pointer becomes <code class="language-plaintext highlighter-rouge">$fe</code>, or memory location <code class="language-plaintext highlighter-rouge">$01fe</code>, and so on.</p>

<p>Two of the stack instructions are <code class="language-plaintext highlighter-rouge">PHA</code> and <code class="language-plaintext highlighter-rouge">PLA</code>, “push accumulator” and “pull
accumulator”. Below is an example of these two in action.</p>

<div class="widget">
  <div class="buttons">
    <input type="button" value="Assemble" class="assembleButton" />
    <input type="button" value="Run" class="runButton" />
    <input type="button" value="Reset" class="resetButton" />
    <input type="button" value="Hexdump" class="hexdumpButton" />
    <input type="button" value="Disassemble" class="disassembleButton" />
    <input type="button" value="Notes" class="notesButton" />
  </div>

  <textarea class="code">

  LDX #$00
  LDY #$00
firstloop:
  TXA
  STA $0200,Y
  PHA
  INX
  INY
  CPY #$10
  BNE firstloop ;loop until Y is $10
secondloop:
  PLA
  STA $0200,Y
  INY
  CPY #$20      ;loop until Y is $20
  BNE secondloop

  </textarea>

  <canvas class="screen" width="160" height="160"></canvas>

  <div class="debugger">
    <input type="checkbox" class="debug" name="debug" />
    <label for="debug">Debugger</label>
    <div class="minidebugger"></div>
    <div class="buttons">
      <input type="button" value="Step" class="stepButton" />
      <input type="button" value="Jump to..." class="gotoButton" />
    </div>
  </div>

  <div class="monitorControls">
    <label for="monitoring">Monitor</label>
    <input type="checkbox" class="monitoring" name="monitoring" />

    <label for="start">Start: $</label>
    <input type="text" value="0" class="start" name="start" />
    <label for="length">Length: $</label>
    <input type="text" value="ff" class="length" name="length" />
  </div>

  <div class="monitor"><pre><code></code></pre></div>
  <div class="messages"><pre><code></code></pre></div>
  <div class="execution-dump"><pre><code></code></pre></div>
  <input type="button" value="Copy Execution Dump" class="copy-execution-dump" />      

  <div class="notes" style="display: none">Notes:

Memory location $fe contains a new random byte on every instruction.
Memory location $ff contains the ascii code of the last key pressed.

Memory locations $200 to $5ff map to the screen pixels. Different values will
draw different colour pixels. The colours are:

$0: Black
$1: White
$2: Red
$3: Cyan
$4: Purple
$5: Green
$6: Blue
$7: Yellow
$8: Orange
$9: Brown
$a: Light red
$b: Dark grey
$c: Grey
$d: Light green
$e: Light blue
$f: Light grey
    </div>
</div>

<p><code class="language-plaintext highlighter-rouge">X</code> holds the pixel colour, and <code class="language-plaintext highlighter-rouge">Y</code> holds the position of the current pixel.
The first loop draws the current colour as a pixel (via the <code class="language-plaintext highlighter-rouge">A</code> register),
pushes the colour to the stack, then increments the colour and position.  The
second loop pops the stack, draws the popped colour as a pixel, then increments
the position. As should be expected, this creates a mirrored pattern.</p>

<h2 id="jumping">Jumping</h2>

<p>Jumping is like branching with two main differences. First, jumps are not
conditionally executed, and second, they take a two-byte absolute address. For
small programs, this second detail isn’t very important, as you’ll mostly be
using labels, and the assembler works out the correct memory location from the
label. For larger programs though, jumping is the only way to move from one
section of the code to another.</p>

<h3 id="jmp">JMP</h3>

<p><code class="language-plaintext highlighter-rouge">JMP</code> is an unconditional jump. Here’s a really simple example to show it in action:</p>

<div class="widget">
  <div class="buttons">
    <input type="button" value="Assemble" class="assembleButton" />
    <input type="button" value="Run" class="runButton" />
    <input type="button" value="Reset" class="resetButton" />
    <input type="button" value="Hexdump" class="hexdumpButton" />
    <input type="button" value="Disassemble" class="disassembleButton" />
    <input type="button" value="Notes" class="notesButton" />
  </div>

  <textarea class="code">

  LDA #$03
  JMP there
  BRK
  BRK
  BRK
there:
  STA $0200

  </textarea>

  <canvas class="screen" width="160" height="160"></canvas>

  <div class="debugger">
    <input type="checkbox" class="debug" name="debug" />
    <label for="debug">Debugger</label>
    <div class="minidebugger"></div>
    <div class="buttons">
      <input type="button" value="Step" class="stepButton" />
      <input type="button" value="Jump to..." class="gotoButton" />
    </div>
  </div>

  <div class="monitorControls">
    <label for="monitoring">Monitor</label>
    <input type="checkbox" class="monitoring" name="monitoring" />

    <label for="start">Start: $</label>
    <input type="text" value="0" class="start" name="start" />
    <label for="length">Length: $</label>
    <input type="text" value="ff" class="length" name="length" />
  </div>

  <div class="monitor"><pre><code></code></pre></div>
  <div class="messages"><pre><code></code></pre></div>
  <div class="execution-dump"><pre><code></code></pre></div>
  <input type="button" value="Copy Execution Dump" class="copy-execution-dump" />      

  <div class="notes" style="display: none">Notes:

Memory location $fe contains a new random byte on every instruction.
Memory location $ff contains the ascii code of the last key pressed.

Memory locations $200 to $5ff map to the screen pixels. Different values will
draw different colour pixels. The colours are:

$0: Black
$1: White
$2: Red
$3: Cyan
$4: Purple
$5: Green
$6: Blue
$7: Yellow
$8: Orange
$9: Brown
$a: Light red
$b: Dark grey
$c: Grey
$d: Light green
$e: Light blue
$f: Light grey
    </div>
</div>

<h3 id="jsrrts">JSR/RTS</h3>

<p><code class="language-plaintext highlighter-rouge">JSR</code> and <code class="language-plaintext highlighter-rouge">RTS</code> (“jump to subroutine” and “return from subroutine”) are a
dynamic duo that you’ll usually see used together. <code class="language-plaintext highlighter-rouge">JSR</code> is used to jump from
the current location to another part of the code. <code class="language-plaintext highlighter-rouge">RTS</code> returns to the previous
position. This is basically like calling a function and returning.</p>

<p>The processor knows where to return to because <code class="language-plaintext highlighter-rouge">JSR</code> pushes the address minus
one of the next instruction onto the stack before jumping to the given
location. <code class="language-plaintext highlighter-rouge">RTS</code> pops this location, adds one to it, and jumps to that location.
An example:</p>

<div class="widget">
  <div class="buttons">
    <input type="button" value="Assemble" class="assembleButton" />
    <input type="button" value="Run" class="runButton" />
    <input type="button" value="Reset" class="resetButton" />
    <input type="button" value="Hexdump" class="hexdumpButton" />
    <input type="button" value="Disassemble" class="disassembleButton" />
    <input type="button" value="Notes" class="notesButton" />
  </div>

  <textarea class="code">

  JSR init
  JSR loop
  JSR end

init:
  LDX #$00
  RTS

loop:
  INX
  CPX #$05
  BNE loop
  RTS

end:
  BRK

  </textarea>

  <canvas class="screen" width="160" height="160"></canvas>

  <div class="debugger">
    <input type="checkbox" class="debug" name="debug" />
    <label for="debug">Debugger</label>
    <div class="minidebugger"></div>
    <div class="buttons">
      <input type="button" value="Step" class="stepButton" />
      <input type="button" value="Jump to..." class="gotoButton" />
    </div>
  </div>

  <div class="monitorControls">
    <label for="monitoring">Monitor</label>
    <input type="checkbox" class="monitoring" name="monitoring" />

    <label for="start">Start: $</label>
    <input type="text" value="0" class="start" name="start" />
    <label for="length">Length: $</label>
    <input type="text" value="ff" class="length" name="length" />
  </div>

  <div class="monitor"><pre><code></code></pre></div>
  <div class="messages"><pre><code></code></pre></div>
  <div class="execution-dump"><pre><code></code></pre></div>
  <input type="button" value="Copy Execution Dump" class="copy-execution-dump" />      

  <div class="notes" style="display: none">Notes:

Memory location $fe contains a new random byte on every instruction.
Memory location $ff contains the ascii code of the last key pressed.

Memory locations $200 to $5ff map to the screen pixels. Different values will
draw different colour pixels. The colours are:

$0: Black
$1: White
$2: Red
$3: Cyan
$4: Purple
$5: Green
$6: Blue
$7: Yellow
$8: Orange
$9: Brown
$a: Light red
$b: Dark grey
$c: Grey
$d: Light green
$e: Light blue
$f: Light grey
    </div>
</div>

<p>The first instruction causes execution to jump to the <code class="language-plaintext highlighter-rouge">init</code> label. This sets
<code class="language-plaintext highlighter-rouge">X</code>, then returns to the next instruction, <code class="language-plaintext highlighter-rouge">JSR loop</code>. This jumps to the <code class="language-plaintext highlighter-rouge">loop</code>
label, which increments <code class="language-plaintext highlighter-rouge">X</code> until it is equal to <code class="language-plaintext highlighter-rouge">$05</code>. After that we return to
the next instruction, <code class="language-plaintext highlighter-rouge">JSR end</code>, which jumps to the end of the file. This
illustrates how <code class="language-plaintext highlighter-rouge">JSR</code> and <code class="language-plaintext highlighter-rouge">RTS</code> can be used together to create modular code.</p>

<h2 id="snake">Creating a game</h2>

<p>Now, let’s put all this knowledge to good use, and make a game! We’re going to
be making a really simple version of the classic game ‘Snake’.</p>

<p>Even though this will be a simple version, the code will be substantially larger
than all the previous examples. We will need to keep track of several memory
locations together for the various aspects of the game. We can still do
the necessary bookkeeping throughout the program ourselves, as before, but
on a larger scale that quickly becomes tedious and can also lead to bugs that
are difficult to spot. Instead we’ll now let the assembler do some of the
mundane work for us.</p>

<p>In this assembler, we can define descriptive constants (or symbols) that represent
numbers. The rest of the code can then simply use the constants instead of the
literal number, which immediately makes it obvious what we’re dealing with.
You can use letters, digits and underscores in a name.</p>

<p>Here’s an example. Note that immediate operands are still prefixed with a <code class="language-plaintext highlighter-rouge">#</code>.</p>
<div class="widget">
  <div class="buttons">
    <input type="button" value="Assemble" class="assembleButton" />
    <input type="button" value="Run" class="runButton" />
    <input type="button" value="Reset" class="resetButton" />
    <input type="button" value="Hexdump" class="hexdumpButton" />
    <input type="button" value="Disassemble" class="disassembleButton" />
    <input type="button" value="Notes" class="notesButton" />
  </div>

  <textarea class="code">

  define  sysRandom  $fe ; an address
  define  a_dozen    $0c ; a constant
 
  LDA sysRandom  ; equivalent to "LDA $fe"

  LDX #a_dozen   ; equivalent to "LDX #$0c"

  </textarea>

  <canvas class="screen" width="160" height="160"></canvas>

  <div class="debugger">
    <input type="checkbox" class="debug" name="debug" />
    <label for="debug">Debugger</label>
    <div class="minidebugger"></div>
    <div class="buttons">
      <input type="button" value="Step" class="stepButton" />
      <input type="button" value="Jump to..." class="gotoButton" />
    </div>
  </div>

  <div class="monitorControls">
    <label for="monitoring">Monitor</label>
    <input type="checkbox" class="monitoring" name="monitoring" />

    <label for="start">Start: $</label>
    <input type="text" value="0" class="start" name="start" />
    <label for="length">Length: $</label>
    <input type="text" value="ff" class="length" name="length" />
  </div>

  <div class="monitor"><pre><code></code></pre></div>
  <div class="messages"><pre><code></code></pre></div>
  <div class="execution-dump"><pre><code></code></pre></div>
  <input type="button" value="Copy Execution Dump" class="copy-execution-dump" />      

  <div class="notes" style="display: none">Notes:

Memory location $fe contains a new random byte on every instruction.
Memory location $ff contains the ascii code of the last key pressed.

Memory locations $200 to $5ff map to the screen pixels. Different values will
draw different colour pixels. The colours are:

$0: Black
$1: White
$2: Red
$3: Cyan
$4: Purple
$5: Green
$6: Blue
$7: Yellow
$8: Orange
$9: Brown
$a: Light red
$b: Dark grey
$c: Grey
$d: Light green
$e: Light blue
$f: Light grey
    </div>
</div>

<p>The simulator widget below contains the entire source code of the game. I’ll
explain how it works in the following sections.</p>

<p><a href="https://twitter.com/wkjagt">Willem van der Jagt</a> made a <a href="https://gist.github.com/wkjagt/9043907">fully annotated gist
of this source code</a>, so follow along
with that for more details.</p>

<div class="widget">
  <div class="buttons">
    <input type="button" value="Assemble" class="assembleButton" />
    <input type="button" value="Run" class="runButton" />
    <input type="button" value="Reset" class="resetButton" />
    <input type="button" value="Hexdump" class="hexdumpButton" />
    <input type="button" value="Disassemble" class="disassembleButton" />
    <input type="button" value="Notes" class="notesButton" />
  </div>

  <textarea class="code">

;  ___           _        __ ___  __ ___
; / __|_ _  __ _| |_____ / /| __|/  \_  )
; \__ \ ' \/ _` | / / -_) _ \__ \ () / /
; |___/_||_\__,_|_\_\___\___/___/\__/___|

; Change direction: W A S D

define appleL         $00 ; screen location of apple, low byte
define appleH         $01 ; screen location of apple, high byte
define snakeHeadL     $10 ; screen location of snake head, low byte
define snakeHeadH     $11 ; screen location of snake head, high byte
define snakeBodyStart $12 ; start of snake body byte pairs
define snakeDirection $02 ; direction (possible values are below)
define snakeLength    $03 ; snake length, in bytes

; Directions (each using a separate bit)
define movingUp      1
define movingRight   2
define movingDown    4
define movingLeft    8

; ASCII values of keys controlling the snake
define ASCII_w      $77
define ASCII_a      $61
define ASCII_s      $73
define ASCII_d      $64

; System variables
define sysRandom    $fe
define sysLastKey   $ff


  jsr init
  jsr loop

init:
  jsr initSnake
  jsr generateApplePosition
  rts


initSnake:
  lda #movingRight  ;start direction
  sta snakeDirection

  lda #4  ;start length (2 segments)
  sta snakeLength
  
  lda #$11
  sta snakeHeadL
  
  lda #$10
  sta snakeBodyStart
  
  lda #$0f
  sta $14 ; body segment 1
  
  lda #$04
  sta snakeHeadH
  sta $13 ; body segment 1
  sta $15 ; body segment 2
  rts


generateApplePosition:
  ;load a new random byte into $00
  lda sysRandom
  sta appleL

  ;load a new random number from 2 to 5 into $01
  lda sysRandom
  and #$03 ;mask out lowest 2 bits
  clc
  adc #2
  sta appleH

  rts


loop:
  jsr readKeys
  jsr checkCollision
  jsr updateSnake
  jsr drawApple
  jsr drawSnake
  jsr spinWheels
  jmp loop


readKeys:
  lda sysLastKey
  cmp #ASCII_w
  beq upKey
  cmp #ASCII_d
  beq rightKey
  cmp #ASCII_s
  beq downKey
  cmp #ASCII_a
  beq leftKey
  rts
upKey:
  lda #movingDown
  bit snakeDirection
  bne illegalMove

  lda #movingUp
  sta snakeDirection
  rts
rightKey:
  lda #movingLeft
  bit snakeDirection
  bne illegalMove

  lda #movingRight
  sta snakeDirection
  rts
downKey:
  lda #movingUp
  bit snakeDirection
  bne illegalMove

  lda #movingDown
  sta snakeDirection
  rts
leftKey:
  lda #movingRight
  bit snakeDirection
  bne illegalMove

  lda #movingLeft
  sta snakeDirection
  rts
illegalMove:
  rts


checkCollision:
  jsr checkAppleCollision
  jsr checkSnakeCollision
  rts


checkAppleCollision:
  lda appleL
  cmp snakeHeadL
  bne doneCheckingAppleCollision
  lda appleH
  cmp snakeHeadH
  bne doneCheckingAppleCollision

  ;eat apple
  inc snakeLength
  inc snakeLength ;increase length
  jsr generateApplePosition
doneCheckingAppleCollision:
  rts


checkSnakeCollision:
  ldx #2 ;start with second segment
snakeCollisionLoop:
  lda snakeHeadL,x
  cmp snakeHeadL
  bne continueCollisionLoop

maybeCollided:
  lda snakeHeadH,x
  cmp snakeHeadH
  beq didCollide

continueCollisionLoop:
  inx
  inx
  cpx snakeLength          ;got to last section with no collision
  beq didntCollide
  jmp snakeCollisionLoop

didCollide:
  jmp gameOver
didntCollide:
  rts


updateSnake:
  ldx snakeLength
  dex
  txa
updateloop:
  lda snakeHeadL,x
  sta snakeBodyStart,x
  dex
  bpl updateloop

  lda snakeDirection
  lsr
  bcs up
  lsr
  bcs right
  lsr
  bcs down
  lsr
  bcs left
up:
  lda snakeHeadL
  sec
  sbc #$20
  sta snakeHeadL
  bcc upup
  rts
upup:
  dec snakeHeadH
  lda #$1
  cmp snakeHeadH
  beq collision
  rts
right:
  inc snakeHeadL
  lda #$1f
  bit snakeHeadL
  beq collision
  rts
down:
  lda snakeHeadL
  clc
  adc #$20
  sta snakeHeadL
  bcs downdown
  rts
downdown:
  inc snakeHeadH
  lda #$6
  cmp snakeHeadH
  beq collision
  rts
left:
  dec snakeHeadL
  lda snakeHeadL
  and #$1f
  cmp #$1f
  beq collision
  rts
collision:
  jmp gameOver


drawApple:
  ldy #0
  lda sysRandom
  sta (appleL),y
  rts


drawSnake:
  ldx snakeLength
  lda #0
  sta (snakeHeadL,x) ; erase end of tail

  ldx #0
  lda #1
  sta (snakeHeadL,x) ; paint head
  rts


spinWheels:
  ldx #0
spinloop:
  nop
  nop
  dex
  bne spinloop
  rts


gameOver:

  </textarea>

  <canvas class="screen" width="160" height="160"></canvas>

  <div class="debugger">
    <input type="checkbox" class="debug" name="debug" />
    <label for="debug">Debugger</label>
    <div class="minidebugger"></div>
    <div class="buttons">
      <input type="button" value="Step" class="stepButton" />
      <input type="button" value="Jump to..." class="gotoButton" />
    </div>
  </div>

  <div class="monitorControls">
    <label for="monitoring">Monitor</label>
    <input type="checkbox" class="monitoring" name="monitoring" />

    <label for="start">Start: $</label>
    <input type="text" value="0" class="start" name="start" />
    <label for="length">Length: $</label>
    <input type="text" value="ff" class="length" name="length" />
  </div>

  <div class="monitor"><pre><code></code></pre></div>
  <div class="messages"><pre><code></code></pre></div>
  <div class="execution-dump"><pre><code></code></pre></div>
  <input type="button" value="Copy Execution Dump" class="copy-execution-dump" />      

  <div class="notes" style="display: none">Notes:

Memory location $fe contains a new random byte on every instruction.
Memory location $ff contains the ascii code of the last key pressed.

Memory locations $200 to $5ff map to the screen pixels. Different values will
draw different colour pixels. The colours are:

$0: Black
$1: White
$2: Red
$3: Cyan
$4: Purple
$5: Green
$6: Blue
$7: Yellow
$8: Orange
$9: Brown
$a: Light red
$b: Dark grey
$c: Grey
$d: Light green
$e: Light blue
$f: Light grey
    </div>
</div>

<h3 id="overall-structure">Overall structure</h3>

<p>After the initial block of comments (lines starting with semicolons), the first
two lines are:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jsr init
jsr loop
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">init</code> and <code class="language-plaintext highlighter-rouge">loop</code> are both subroutines. <code class="language-plaintext highlighter-rouge">init</code> initializes the game state, and
<code class="language-plaintext highlighter-rouge">loop</code> is the main game loop.</p>

<p>The <code class="language-plaintext highlighter-rouge">loop</code> subroutine itself just calls a number of subroutines sequentially,
before looping back on itself:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>loop:
  jsr readkeys
  jsr checkCollision
  jsr updateSnake
  jsr drawApple
  jsr drawSnake
  jsr spinwheels
  jmp loop
</code></pre></div></div>

<p>First, <code class="language-plaintext highlighter-rouge">readkeys</code> checks to see if one of the direction keys (W, A, S, D) was
pressed, and if so, sets the direction of the snake accordingly. Then,
<code class="language-plaintext highlighter-rouge">checkCollision</code> checks to see if the snake collided with itself or the apple.
<code class="language-plaintext highlighter-rouge">updateSnake</code> updates the internal representation of the snake, based on its
direction. Next, the apple and snake are drawn. Finally, <code class="language-plaintext highlighter-rouge">spinWheels</code> makes the
processor do some busy work, to stop the game from running too quickly. Think
of it like a sleep command. The game keeps running until the snake collides
with the wall or itself.</p>

<h3 id="zero-page-usage">Zero page usage</h3>

<p>The zero page of memory is used to store a number of game state variables, as
noted in the comment block at the top of the game. Everything in <code class="language-plaintext highlighter-rouge">$00</code>, <code class="language-plaintext highlighter-rouge">$01</code>
and <code class="language-plaintext highlighter-rouge">$10</code> upwards is a pair of bytes representing a two-byte memory location
that will be looked up using indirect addressing.  These memory locations will
all be between <code class="language-plaintext highlighter-rouge">$0200</code> and <code class="language-plaintext highlighter-rouge">$05ff</code> - the section of memory corresponding to the
simulator display. For example, if <code class="language-plaintext highlighter-rouge">$00</code> and <code class="language-plaintext highlighter-rouge">$01</code> contained the values <code class="language-plaintext highlighter-rouge">$01</code>
and <code class="language-plaintext highlighter-rouge">$02</code>, they would be referring to the second pixel of the display (
<code class="language-plaintext highlighter-rouge">$0201</code> - remember, the least significant byte comes first in indirect addressing).</p>

<p>The first two bytes hold the location of the apple. This is updated every time
the snake eats the apple. Byte <code class="language-plaintext highlighter-rouge">$02</code> contains the current direction. <code class="language-plaintext highlighter-rouge">1</code> means
up, <code class="language-plaintext highlighter-rouge">2</code> right, <code class="language-plaintext highlighter-rouge">4</code> down, and <code class="language-plaintext highlighter-rouge">8</code> left.  The reasoning behind these numbers will
become clear later.</p>

<p>Finally, byte <code class="language-plaintext highlighter-rouge">$03</code> contains the current length of the snake, in terms of bytes
in memory (so a length of 4 means 2 pixels).</p>

<h3 id="initialization">Initialization</h3>

<p>The <code class="language-plaintext highlighter-rouge">init</code> subroutine defers to two subroutines, <code class="language-plaintext highlighter-rouge">initSnake</code> and
<code class="language-plaintext highlighter-rouge">generateApplePosition</code>. <code class="language-plaintext highlighter-rouge">initSnake</code> sets the snake direction, length, and then
loads the initial memory locations of the snake head and body. The byte pair at
<code class="language-plaintext highlighter-rouge">$10</code> contains the screen location of the head, the pair at <code class="language-plaintext highlighter-rouge">$12</code> contains the
location of the single body segment, and <code class="language-plaintext highlighter-rouge">$14</code> contains the location of the
tail (the tail is the last segment of the body and is drawn in black to keep
the snake moving). This happens in the following code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lda #$11
sta $10
lda #$10
sta $12
lda #$0f
sta $14
lda #$04
sta $11
sta $13
sta $15
</code></pre></div></div>

<p>This loads the value <code class="language-plaintext highlighter-rouge">$11</code> into the memory location <code class="language-plaintext highlighter-rouge">$10</code>, the value <code class="language-plaintext highlighter-rouge">$10</code> into
<code class="language-plaintext highlighter-rouge">$12</code>, and <code class="language-plaintext highlighter-rouge">$0f</code> into <code class="language-plaintext highlighter-rouge">$14</code>. It then loads the value <code class="language-plaintext highlighter-rouge">$04</code> into <code class="language-plaintext highlighter-rouge">$11</code>, <code class="language-plaintext highlighter-rouge">$13</code>
and <code class="language-plaintext highlighter-rouge">$15</code>. This leads to memory like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0010: 11 04 10 04 0f 04
</code></pre></div></div>

<p>which represents the indirectly-addressed memory locations <code class="language-plaintext highlighter-rouge">$0411</code>, <code class="language-plaintext highlighter-rouge">$0410</code> and
<code class="language-plaintext highlighter-rouge">$040f</code> (three pixels in the middle of the display). I’m labouring this point,
but it’s important to fully grok how indirect addressing works.</p>

<p>The next subroutine, <code class="language-plaintext highlighter-rouge">generateApplePosition</code>, sets the apple location to a
random position on the display. First, it loads a random byte into the
accumulator (<code class="language-plaintext highlighter-rouge">$fe</code> is a random number generator in this simulator). This is
stored into <code class="language-plaintext highlighter-rouge">$00</code>. Next, a different random byte is loaded into the
accumulator, which is then <code class="language-plaintext highlighter-rouge">AND</code>-ed with the value <code class="language-plaintext highlighter-rouge">$03</code>. This part requires a
bit of a detour.</p>

<p>The hex value <code class="language-plaintext highlighter-rouge">$03</code> is represented in binary as <code class="language-plaintext highlighter-rouge">00000011</code>. The <code class="language-plaintext highlighter-rouge">AND</code> opcode
performs a bitwise AND of the argument with the accumulator. For example, if
the accumulator contains the binary value <code class="language-plaintext highlighter-rouge">10101010</code>, then the result of <code class="language-plaintext highlighter-rouge">AND</code>
with <code class="language-plaintext highlighter-rouge">00000011</code> will be <code class="language-plaintext highlighter-rouge">00000010</code>.</p>

<p>The effect of this is to mask out the least significant two bits of the
accumulator, setting the others to zero. This converts a number in the range of
0–255 to a number in the range of 0–3.</p>

<p>After this, the value <code class="language-plaintext highlighter-rouge">2</code> is added to the accumulator, to create a final random
number in the range 2–5.</p>

<p>The result of this subroutine is to load a random byte into <code class="language-plaintext highlighter-rouge">$00</code>, and a random
number between 2 and 5 into <code class="language-plaintext highlighter-rouge">$01</code>. Because the least significant byte comes
first with indirect addressing, this translates into a memory address between
<code class="language-plaintext highlighter-rouge">$0200</code> and <code class="language-plaintext highlighter-rouge">$05ff</code>: the exact range used to draw the display.</p>

<h3 id="the-game-loop">The game loop</h3>

<p>Nearly all games have at their heart a game loop. All game loops have the same
basic form: accept user input, update the game state, and render the game
state. This loop is no different.</p>

<h4 id="reading-the-input">Reading the input</h4>

<p>The first subroutine, <code class="language-plaintext highlighter-rouge">readKeys</code>, takes the job of accepting user input. The
memory location <code class="language-plaintext highlighter-rouge">$ff</code> holds the ascii code of the most recent key press in this
simulator. The value is loaded into the accumulator, then compared to <code class="language-plaintext highlighter-rouge">$77</code>
(the hex code for W), <code class="language-plaintext highlighter-rouge">$64</code> (D), <code class="language-plaintext highlighter-rouge">$73</code> (S) and <code class="language-plaintext highlighter-rouge">$61</code> (A). If any of these
comparisons are successful, the program branches to the appropriate section.
Each section (<code class="language-plaintext highlighter-rouge">upKey</code>, <code class="language-plaintext highlighter-rouge">rightKey</code>, etc.) first checks to see if the current
direction is the opposite of the new direction. This requires another little detour.</p>

<p>As stated before, the four directions are represented internally by the numbers
1, 2, 4 and 8. Each of these numbers is a power of 2, thus they are represented
by a binary number with a single <code class="language-plaintext highlighter-rouge">1</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 =&gt; 0001 (up)
2 =&gt; 0010 (right)
4 =&gt; 0100 (down)
8 =&gt; 1000 (left)
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">BIT</code> opcode is similar to <code class="language-plaintext highlighter-rouge">AND</code>, but the calculation is only used to set
the zero flag - the actual result is discarded. The zero flag is set only if the
result of AND-ing the accumulator with argument is zero. When we’re looking at
powers of two, the zero flag will only be set if the two numbers are not the
same. For example, <code class="language-plaintext highlighter-rouge">0001 AND 0001</code> is not zero, but <code class="language-plaintext highlighter-rouge">0001 AND 0010</code> is zero.</p>

<p>So, looking at <code class="language-plaintext highlighter-rouge">upKey</code>, if the current direction is down (4), the bit test will
be zero. <code class="language-plaintext highlighter-rouge">BNE</code> means “branch if the zero flag is clear”, so in this case we’ll
branch to <code class="language-plaintext highlighter-rouge">illegalMove</code>, which just returns from the subroutine. Otherwise, the
new direction (1 in this case) is stored in the appropriate memory location.</p>

<h4 id="updating-the-game-state">Updating the game state</h4>

<p>The next subroutine, <code class="language-plaintext highlighter-rouge">checkCollision</code>, defers to <code class="language-plaintext highlighter-rouge">checkAppleCollision</code> and
<code class="language-plaintext highlighter-rouge">checkSnakeCollision</code>. <code class="language-plaintext highlighter-rouge">checkAppleCollision</code> just checks to see if the two
bytes holding the location of the apple match the two bytes holding the
location of the head. If they do, the length is increased and a new apple
position is generated.</p>

<p><code class="language-plaintext highlighter-rouge">checkSnakeCollision</code> loops through the snake’s body segments, checking each
byte pair against the head pair. If there is a match, then game over.</p>

<p>After collision detection, we update the snake’s location. This is done at a
high level like so: First, move each byte pair of the body up one position in
memory. Second, update the head according to the current direction. Finally, if
the head is out of bounds, handle it as a collision. I’ll illustrate this with
some ascii art. Each pair of brackets contains an x,y coordinate rather than a
pair of bytes for simplicity.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  0    1    2    3    4
Head                 Tail

[1,5][1,4][1,3][1,2][2,2]    Starting position

[1,5][1,4][1,3][1,2][1,2]    Value of (3) is copied into (4)

[1,5][1,4][1,3][1,3][1,2]    Value of (2) is copied into (3)

[1,5][1,4][1,4][1,3][1,2]    Value of (1) is copied into (2)

[1,5][1,5][1,4][1,3][1,2]    Value of (0) is copied into (1)

[0,5][1,5][1,4][1,3][1,2]    Value of (0) is updated based on direction
</code></pre></div></div>

<p>At a low level, this subroutine is slightly more complex. First, the length is
loaded into the <code class="language-plaintext highlighter-rouge">X</code> register, which is then decremented. The snippet below
shows the starting memory for the snake.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Memory location: $10 $11 $12 $13 $14 $15

Value:           $11 $04 $10 $04 $0f $04
</code></pre></div></div>

<p>The length is initialized to <code class="language-plaintext highlighter-rouge">4</code>, so <code class="language-plaintext highlighter-rouge">X</code> starts off as <code class="language-plaintext highlighter-rouge">3</code>. <code class="language-plaintext highlighter-rouge">LDA $10,x</code> loads the
value of <code class="language-plaintext highlighter-rouge">$13</code> into <code class="language-plaintext highlighter-rouge">A</code>, then <code class="language-plaintext highlighter-rouge">STA $12,x</code> stores this value into <code class="language-plaintext highlighter-rouge">$15</code>. <code class="language-plaintext highlighter-rouge">X</code> is
decremented, and we loop. Now <code class="language-plaintext highlighter-rouge">X</code> is <code class="language-plaintext highlighter-rouge">2</code>, so we load <code class="language-plaintext highlighter-rouge">$12</code> and store it into
<code class="language-plaintext highlighter-rouge">$14</code>. This loops while <code class="language-plaintext highlighter-rouge">X</code> is positive (<code class="language-plaintext highlighter-rouge">BPL</code> means “branch if positive”).</p>

<p>Once the values have been shifted down the snake, we have to work out what to
do with the head. The direction is first loaded into <code class="language-plaintext highlighter-rouge">A</code>. <code class="language-plaintext highlighter-rouge">LSR</code> means “logical
shift right”, or “shift all the bits one position to the right”. The least
significant bit is shifted into the carry flag, so if the accumulator is <code class="language-plaintext highlighter-rouge">1</code>,
after <code class="language-plaintext highlighter-rouge">LSR</code> it is <code class="language-plaintext highlighter-rouge">0</code>, with the carry flag set.</p>

<p>To test whether the direction is <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">4</code> or <code class="language-plaintext highlighter-rouge">8</code>, the code continually
shifts right until the carry is set. One <code class="language-plaintext highlighter-rouge">LSR</code> means “up”, two means “right”,
and so on.</p>

<p>The next bit updates the head of the snake depending on the direction. This is
probably the most complicated part of the code, and it’s all reliant on how
memory locations map to the screen, so let’s look at that in more detail.</p>

<p>You can think of the screen as four horizontal strips of 32 × 8 pixels.
These strips map to <code class="language-plaintext highlighter-rouge">$0200-$02ff</code>, <code class="language-plaintext highlighter-rouge">$0300-$03ff</code>, <code class="language-plaintext highlighter-rouge">$0400-$04ff</code> and <code class="language-plaintext highlighter-rouge">$0500-$05ff</code>.
The first rows of pixels are <code class="language-plaintext highlighter-rouge">$0200-$021f</code>, <code class="language-plaintext highlighter-rouge">$0220-$023f</code>, <code class="language-plaintext highlighter-rouge">$0240-$025f</code>, etc.</p>

<p>As long as you’re moving within one of these horizontal strips, things are
simple. For example, to move right, just increment the least significant byte
(e.g. <code class="language-plaintext highlighter-rouge">$0200</code> becomes <code class="language-plaintext highlighter-rouge">$0201</code>). To go down, add <code class="language-plaintext highlighter-rouge">$20</code> (e.g. <code class="language-plaintext highlighter-rouge">$0200</code> becomes
<code class="language-plaintext highlighter-rouge">$0220</code>). Left and up are the reverse.</p>

<p>Going between sections is more complicated, as we have to take into account the
most significant byte as well. For example, going down from <code class="language-plaintext highlighter-rouge">$02e1</code> should lead
to <code class="language-plaintext highlighter-rouge">$0301</code>. Luckily, this is fairly easy to accomplish. Adding <code class="language-plaintext highlighter-rouge">$20</code> to <code class="language-plaintext highlighter-rouge">$e1</code>
results in <code class="language-plaintext highlighter-rouge">$01</code> and sets the carry bit. If the carry bit was set, we know we
also need to increment the most significant byte.</p>

<p>After a move in each direction, we also need to check to see if the head
would become out of bounds. This is handled differently for each direction. For
left and right, we can check to see if the head has effectively “wrapped
around”. Going right from <code class="language-plaintext highlighter-rouge">$021f</code> by incrementing the least significant byte
would lead to <code class="language-plaintext highlighter-rouge">$0220</code>, but this is actually jumping from the last pixel of the
first row to the first pixel of the second row. So, every time we move right,
we need to check if the new least significant byte is a multiple of <code class="language-plaintext highlighter-rouge">$20</code>. This
is done using a bit check against the mask <code class="language-plaintext highlighter-rouge">$1f</code>. Hopefully the illustration
below will show you how masking out the lowest 5 bits reveals whether a number
is a multiple of <code class="language-plaintext highlighter-rouge">$20</code> or not.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$20: 0010 0000
$40: 0100 0000
$60: 0110 0000

$1f: 0001 1111
</code></pre></div></div>

<p>I won’t explain in depth how each of the directions work, but the above
explanation should give you enough to work it out with a bit of study.</p>

<h4 id="rendering-the-game">Rendering the game</h4>

<p>Because the game state is stored in terms of pixel locations, rendering the
game is very straightforward. The first subroutine, <code class="language-plaintext highlighter-rouge">drawApple</code>, is extremely
simple. It sets <code class="language-plaintext highlighter-rouge">Y</code> to zero, loads a random colour into the accumulator, then
stores this value into <code class="language-plaintext highlighter-rouge">($00),y</code>. <code class="language-plaintext highlighter-rouge">$00</code> is where the location of the apple is
stored, so <code class="language-plaintext highlighter-rouge">($00),y</code> dereferences to this memory location. Read the “Indirect
indexed” section in <a href="#addressing">Addressing modes</a> for more details.</p>

<p>Next comes <code class="language-plaintext highlighter-rouge">drawSnake</code>. This is pretty simple too - we first undraw the tail
and then draw the head. <code class="language-plaintext highlighter-rouge">X</code> is set to the length of the snake, so we can index
to the right pixel, and we set <code class="language-plaintext highlighter-rouge">A</code> to zero then perform the write using the
indexed indirect addressing mode. Then we reload <code class="language-plaintext highlighter-rouge">X</code> to index to the head, set
<code class="language-plaintext highlighter-rouge">A</code> to one and store it at <code class="language-plaintext highlighter-rouge">($10,x)</code>. <code class="language-plaintext highlighter-rouge">$10</code> stores the two-byte location of
the head, so this draws a white pixel at the current head position. As only
the head and the tail of the snake move, this is enough to keep the snake
moving.</p>

<p>The last subroutine, <code class="language-plaintext highlighter-rouge">spinWheels</code>, is just there because the game would run too
fast otherwise. All <code class="language-plaintext highlighter-rouge">spinWheels</code> does is count <code class="language-plaintext highlighter-rouge">X</code> down from zero until it hits
zero again. The first <code class="language-plaintext highlighter-rouge">dex</code> wraps, making <code class="language-plaintext highlighter-rouge">X</code> <code class="language-plaintext highlighter-rouge">#$ff</code>.</p>


      </section>
      <footer>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script src="simulator/es5-shim.js"></script>
    <script src="lz-string.js"></script>
    <script src="simulator/assembler.js"></script>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
